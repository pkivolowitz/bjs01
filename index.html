<html>
<head>
	<script src="https://preview.babylonjs.com/babylon.js"></script>
	<script src="https://preview.babylonjs.com/materialsLibrary/babylonjs.materials.min.js"></script>
	<script src="https://preview.babylonjs.com/Oimo.js"></script>
	<script src="./brick.js"></script>
	<title>Test 01</title>
	<style>
		body,
		#renderCanvas {
			width: 100%;
			height: 100%;
			margin: 0; 
			padding: 0;
		}
	</style>
</head>
<body>
	<canvas id="renderCanvas"></canvas>
	<script>
		const canvas = document.getElementById("renderCanvas");
		const engine = new BABYLON.Engine(canvas, true);
		const scene  = new BABYLON.Scene(engine);
		const origin = new BABYLON.Vector3.Zero();
		const x_axis = new BABYLON.Vector3(1, 0, 0);
		const y_axis = new BABYLON.Vector3(0, 1, 0);
		const z_axis = new BABYLON.Vector3(0, 0, 1);
		const camera = new BABYLON.ArcRotateCamera("Camera", Math.PI / 4, Math.PI / 3, 18, origin, scene);
		const light  = new BABYLON.HemisphericLight("light", new BABYLON.Vector3(0, 0, 10));
		const sky_blue = new BABYLON.Color3(0.529, 0.808, 0.922);

		var gravityVector = new BABYLON.Vector3(0, -9.81, 0);
		var physicsPlugin = new BABYLON.OimoJSPlugin();
		scene.enablePhysics(gravityVector, physicsPlugin);

		window.addEventListener("resize", function () {
				engine.resize();
		});

		scene.actionManager = new BABYLON.ActionManager(scene);
		scene.registerAfterRender(animate);
		scene.onKeyboardObservable.add((kbInfo) => {
			switch (kbInfo.type) {
				case BABYLON.KeyboardEventTypes.KEYDOWN:
					switch (kbInfo.event.key) {
						case ' ':
							console.log('fire');
							break;
					}
					break;
			}
		});

		/* DO NOT DELETE THIS SNIPPET!!!
		
		var box = BABYLON.MeshBuilder.CreateBox("box", {}, scene);
		let box_material = new BABYLON.NodeMaterial("box_material", scene);
		box_material.loadAsync("nm.json").then(() => {
				box_material.build(true);
		});
		box.material = box_material;
		*/

		const b = new Brick(scene);
		b.SetPosition(new BABYLON.Vector3(0, Brick.height / 2.0, 0));
		const c = new Brick(scene);
		c.SetPosition(new BABYLON.Vector3(4, Brick.height / 2.0, 4));

		const ground = BABYLON.MeshBuilder.CreateGround("ground", { width: 20, height: 20 }, scene);
		ground.physicsImposter = new BABYLON.PhysicsImpostor(ground, BABYLON.PhysicsImpostor.BoxImpostor, { mass: 0, restitution: 0.0 }, scene);

		const ElapsedTime = function () {
			if (typeof ElapsedTime.start_time == 'undefined') {
				ElapsedTime.start_time = new Date();
			}
			let end_time = new Date();
			return (end_time - ElapsedTime.start_time) / 1000.0;
		}

		const InterframeElapsedTime = function () {
			if (typeof InterframeElapsedTime.last_frame_time == 'undefined') {
				InterframeElapsedTime.last_frame_time = ElapsedTime();
			}
			let now = ElapsedTime();
			let delta_time = now - InterframeElapsedTime.last_frame_time;
			InterframeElapsedTime.last_frame_time = now;
			return delta_time;
		}

		const createScene = function () {
			// This is run once.
			scene.clearColor = sky_blue;
			camera.attachControl(canvas, true);
			light.intensity = 0.8;	
			return scene;
		};

		const sceneToRender = createScene();
		engine.runRenderLoop(function () {
			sceneToRender.render();
		});

		function animate() {
			let delta_time = InterframeElapsedTime();
		}

	</script>
</body>

</html>